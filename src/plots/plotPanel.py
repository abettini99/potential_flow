import numpy as np
import math as math
from matplotlib import path
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import plotly.figure_factory as ff

np.seterr(under='ignore')

#Panel method implementations originally from https://github.com/jte0419/Panel_Methods
#Modified by Valter Somlai for the app's purposes

def STREAMLINE_SPM(XP,YP,XB,YB,phi,S):
    
    # Number of panels
    numPan = len(XB)-1                                                          # Number of panels (control points)
    
    # Initialize arrays
    Mx = np.zeros(numPan)                                                       # Initialize Mx integral array
    My = np.zeros(numPan)                                                       # Initialize My integral array
    
    # Compute Mx and My
    for j in range(numPan):                                                     # Loop over all panels
        # Compute intermediate values
        A = -(XP-XB[j])*np.cos(phi[j]) - (YP-YB[j])*np.sin(phi[j])              # A term
        B  = (XP-XB[j])**2 + (YP-YB[j])**2;                                     # B term
        Cx = -np.cos(phi[j]);                                                   # Cx term (X-direction)
        Dx = XP-XB[j];                                                          # Dx term (X-direction)
        Cy = -np.sin(phi[j]);                                                   # Cy term (Y-direction)
        Dy = YP-YB[j];                                                          # Dy term (Y-direction)
        E  = math.sqrt(B-A**2);                                                 # E term
        if (E == 0 or np.iscomplex(E) or np.isnan(E) or np.isinf(E)):           # If E term is 0 or complex or a NAN or an INF
            Mx[j] = 0                                                           # Set Mx value equal to zero
            My[j] = 0                                                           # Set My value equal to zero
        else:
            # Compute Mx, Ref [1]
            term1 = 0.5*Cx*np.log((S[j]**2 + 2*A*S[j]+B)/B);                    # First term in Mx equation
            term2 = ((Dx-A*Cx)/E)*(math.atan2((S[j]+A),E) - math.atan2(A,E));   # Second term in Mx equation
            Mx[j] = term1 + term2;                                              # Compute Mx integral
            
            # Compute My, Ref [1]
            term1 = 0.5*Cy*np.log((S[j]**2 + 2*A*S[j]+B)/B);                    # First term in My equation
            term2 = ((Dy-A*Cy)/E)*(math.atan2((S[j]+A),E) - math.atan2(A,E));   # Second term in My equation
            My[j] = term1 + term2;                                              # Compute My integral

        # Zero out any problem values
        if (np.iscomplex(Mx[j]) or np.isnan(Mx[j]) or np.isinf(Mx[j])):         # If Mx term is complex or a NAN or an INF
            Mx[j] = 0                                                           # Set Mx value equal to zero
        if (np.iscomplex(My[j]) or np.isnan(My[j]) or np.isinf(My[j])):         # If My term is complex or a NAN or an INF
            My[j] = 0                                                           # Set My value equal to zero
    
    return Mx, My                                                               # Return both Mx and My matrices

def COMPUTE_IJ_SPM(XC,YC,XB,YB,phi,S):
    
    # Number of panels
    numPan = len(XC)                                                                # Number of panels/control points
    
    # Initialize arrays
    I = np.zeros([numPan,numPan])                                                   # Initialize I integral matrix
    J = np.zeros([numPan,numPan])                                                   # Initialize J integral matrix
    
    # Compute integral
    for i in range(numPan):                                                         # Loop over i panels
        for j in range(numPan):                                                     # Loop over j panels
            if (j != i):                                                            # If the i and j panels are not the same
                # Compute intermediate values
                A  = -(XC[i]-XB[j])*np.cos(phi[j])-(YC[i]-YB[j])*np.sin(phi[j])     # A term
                B  = (XC[i]-XB[j])**2 + (YC[i]-YB[j])**2                            # B term
                Cn = np.sin(phi[i]-phi[j])                                          # C term (normal)
                Dn = -(XC[i]-XB[j])*np.sin(phi[i])+(YC[i]-YB[j])*np.cos(phi[i])     # D term (normal)
                Ct = -np.cos(phi[i]-phi[j])                                         # C term (tangential)
                Dt = (XC[i]-XB[j])*np.cos(phi[i])+(YC[i]-YB[j])*np.sin(phi[i])      # D term (tangential)
                E  = np.sqrt(B-A**2)                                                # E term
                if (E == 0 or np.iscomplex(E) or np.isnan(E) or np.isinf(E)):       # If E term is 0 or complex or a NAN or an INF
                    I[i,j] = 0                                                      # Set I value equal to zero
                    J[i,j] = 0                                                      # Set J value equal to zero
                else:
                    # Compute I (needed for normal velocity), Ref [1]
                    term1  = 0.5*Cn*np.log((S[j]**2 + 2*A*S[j] + B)/B)              # First term in I equation
                    term2  = ((Dn-A*Cn)/E)*(math.atan2((S[j]+A),E)-math.atan2(A,E)) # Second term in I equation
                    I[i,j] = term1 + term2                                          # Compute I integral
                    
                    # Compute J (needed for tangential velocity), Ref [2]
                    term1  = 0.5*Ct*np.log((S[j]**2 + 2*A*S[j] + B)/B)              # First term in I equation
                    term2  = ((Dt-A*Ct)/E)*(math.atan2((S[j]+A),E)-math.atan2(A,E)) # Second term in I equation
                    J[i,j] = term1 + term2                                          # Compute J integral
                
            # Zero out any problem values
            if (np.iscomplex(I[i,j]) or np.isnan(I[i,j]) or np.isinf(I[i,j])):      # If I term is complex or a NAN or an INF
                I[i,j] = 0                                                          # Set I value equal to zero
            if (np.iscomplex(J[i,j]) or np.isnan(J[i,j]) or np.isinf(J[i,j])):      # If J term is complex or a NAN or an INF
                J[i,j] = 0                                                          # Set J value equal to zero
    
    return I, J                                                                     # Return both I and J matrices

def STREAMLINE_VPM(XP,YP,XB,YB,phi,S):
    
    # Number of panels
    numPan = len(XB)-1                                                          # Number of panels (control points)
    
    # Initialize arrays
    Nx = np.zeros(numPan)                                                       # Initialize Nx integral array
    Ny = np.zeros(numPan)                                                       # Initialize Ny integral array
    
    # Compute Nx and Ny
    for j in range(numPan):                                                     # Loop over all panels
        # Compute intermediate values
        A = -(XP-XB[j])*np.cos(phi[j]) - (YP-YB[j])*np.sin(phi[j])              # A term
        B  = (XP-XB[j])**2 + (YP-YB[j])**2                                      # B term
        Cx = np.sin(phi[j])                                                     # Cx term (X-direction)
        Dx = -(YP-YB[j])                                                        # Dx term (X-direction)
        Cy = -np.cos(phi[j])                                                    # Cy term (Y-direction)
        Dy = XP-XB[j]                                                           # Dy term (Y-direction)
        E  = math.sqrt(B-A**2)                                                  # E term
        if (E == 0 or np.iscomplex(E) or np.isnan(E) or np.isinf(E)):           # If E term is 0 or complex or a NAN or an INF
            Nx[j] = 0                                                           # Set Nx value equal to zero
            Ny[j] = 0                                                           # Set Ny value equal to zero
        else:
            # Compute Nx, Ref [1]
            term1 = 0.5*Cx*np.log((S[j]**2 + 2*A*S[j]+B)/B);                    # First term in Nx equation
            term2 = ((Dx-A*Cx)/E)*(math.atan2((S[j]+A),E) - math.atan2(A,E));   # Second term in Nx equation
            Nx[j] = term1 + term2;                                              # Compute Nx integral
            
            # Compute Ny, Ref [1]
            term1 = 0.5*Cy*np.log((S[j]**2 + 2*A*S[j]+B)/B);                    # First term in Ny equation
            term2 = ((Dy-A*Cy)/E)*(math.atan2((S[j]+A),E) - math.atan2(A,E));   # Second term in Ny equation
            Ny[j] = term1 + term2;                                              # Compute Ny integral
            
        # Zero out any problem values
        if (np.iscomplex(Nx[j]) or np.isnan(Nx[j]) or np.isinf(Nx[j])):         # If Nx term is complex or a NAN or an INF
            Nx[j] = 0                                                           # Set Nx value equal to zero
        if (np.iscomplex(Ny[j]) or np.isnan(Ny[j]) or np.isinf(Ny[j])):         # If Ny term is complex or a NAN or an INF
            Ny[j] = 0                                                           # Set Ny value equal to zero
    
    return Nx, Ny                                                               # Return both Nx and Ny matrices


def COMPUTE_KL_VPM(XC,YC,XB,YB,phi,S):
    
    # Number of panels
    numPan = len(XC)                                                                # Number of panels
    
    # Initialize arrays
    K = np.zeros([numPan,numPan])                                                   # Initialize K integral matrix
    L = np.zeros([numPan,numPan])                                                   # Initialize L integral matrix
    
    # Compute integral
    for i in range(numPan):                                                         # Loop over i panels
        for j in range(numPan):                                                     # Loop over j panels
            if (j != i):                                                            # If panel j is not the same as panel i
                # Compute intermediate values
                A  = -(XC[i]-XB[j])*np.cos(phi[j])-(YC[i]-YB[j])*np.sin(phi[j])     # A term
                B  = (XC[i]-XB[j])**2 + (YC[i]-YB[j])**2                            # B term
                Cn = -np.cos(phi[i]-phi[j])                                         # C term (normal)
                Dn = (XC[i]-XB[j])*np.cos(phi[i])+(YC[i]-YB[j])*np.sin(phi[i])      # D term (normal)
                Ct = np.sin(phi[j]-phi[i])                                          # C term (tangential)
                Dt = (XC[i]-XB[j])*np.sin(phi[i])-(YC[i]-YB[j])*np.cos(phi[i])      # D term (tangential)
                E  = np.sqrt(B-A**2)                                                # E term
                if (E == 0 or np.iscomplex(E) or np.isnan(E) or np.isinf(E)):       # If E term is 0 or complex or a NAN or an INF
                    K[i,j] = 0                                                      # Set K value equal to zero
                    L[i,j] = 0                                                      # Set L value equal to zero
                else:
                    # Compute K
                    term1  = 0.5*Cn*np.log((S[j]**2 + 2*A*S[j] + B)/B)              # First term in K equation
                    term2  = ((Dn-A*Cn)/E)*(math.atan2((S[j]+A),E)-math.atan2(A,E)) # Second term in K equation
                    K[i,j] = term1 + term2                                          # Compute K integral
                    
                    # Compute L
                    term1  = 0.5*Ct*np.log((S[j]**2 + 2*A*S[j] + B)/B)              # First term in L equation
                    term2  = ((Dt-A*Ct)/E)*(math.atan2((S[j]+A),E)-math.atan2(A,E)) # Second term in L equation
                    L[i,j] = term1 + term2                                          # Compute L integral
            
            # Zero out any problem values
            if (np.iscomplex(K[i,j]) or np.isnan(K[i,j]) or np.isinf(K[i,j])):      # If K term is complex or a NAN or an INF
                K[i,j] = 0                                                          # Set K value equal to zero
            if (np.iscomplex(L[i,j]) or np.isnan(L[i,j]) or np.isinf(L[i,j])):      # If L term is complex or a NAN or an INF
                L[i,j] = 0                                                          # Set L value equal to zero
    
    return K, L


def airfoil_storage(name):

    if name == "NACA2412":

        XB = np.array([1.0, 0.999113, 0.997715, 0.996224, 0.994629, 0.992914, 
                    0.99106, 0.989044, 0.986835, 0.984396, 0.981674, 0.978601, 
                    0.975079, 0.970967, 0.966051, 0.959991, 0.952218, 0.941738, 
                    0.926869, 0.90556, 0.877712, 0.846199, 0.813468, 0.780424, 
                    0.747319, 0.714241, 0.681235, 0.648344, 0.615605, 0.583057, 
                    0.550741, 0.518694, 0.486954, 0.455537, 0.424384, 0.393119, 
                    0.361443, 0.330132, 0.299533, 0.269805, 0.241084, 0.213532, 
                    0.187354, 0.162829, 0.140322, 0.120247, 0.102934, 0.088452, 
                    0.076562, 0.066841, 0.058838, 0.052165, 0.046518, 0.041671, 
                    0.037456, 0.033748, 0.030454, 0.027501, 0.024835, 0.022413, 
                    0.020201, 0.018172, 0.016305, 0.014582, 0.012988, 0.011513, 
                    0.010146, 0.00888, 0.00771, 0.00663, 0.005637, 0.004729, 0.003904, 
                    0.003161, 0.002499, 0.001917, 0.001416, 0.000994, 0.000651, 0.000383, 
                    0.000189, 6.5e-05, 6e-06, 8e-06, 7e-05, 0.000195, 0.000386, 0.000645, 
                    0.000974, 0.001373, 0.001844, 0.002388, 0.003007, 0.003701, 0.004473, 
                    0.005326, 0.006262, 0.007286, 0.008404, 0.009622, 0.010948, 0.012392, 
                    0.013965, 0.015683, 0.017563, 0.019628, 0.021903, 0.024424, 0.027232, 
                    0.030382, 0.033942, 0.038001, 0.042674, 0.048109, 0.054498, 0.062073, 
                    0.071105, 0.081858, 0.094531, 0.109172, 0.125663, 0.143767, 0.163217, 
                    0.183778, 0.205265, 0.227538, 0.250488, 0.274033, 0.298105, 0.322654, 
                    0.347649, 0.373106, 0.399196, 0.426283, 0.454038, 0.482187, 0.510624, 
                    0.539295, 0.568165, 0.597203, 0.626382, 0.655673, 0.68505, 0.714488, 
                    0.743959, 0.773436, 0.802873, 0.832171, 0.861019, 0.888454, 0.912379, 
                    0.930851, 0.944156, 0.953824, 0.961145, 0.966927, 0.971658, 0.975638, 
                    0.97906, 0.982053, 0.98471, 0.987094, 0.989255, 0.99123, 0.993047, 0.994729, 
                    0.996294, 0.997757, 0.999129, 1.0])

        YB = np.array([-0.00126, -0.001325, -0.001428, -0.001538, -0.001655, -0.00178, -0.001916, 
                    -0.002063, -0.002224, -0.002402, -0.002599, -0.002822, -0.003077, -0.003373, 
                    -0.003726, -0.00416, -0.004714, -0.005456, -0.0065, -0.007982, -0.009895, -0.012032, 
                    -0.014225, -0.016414, -0.018583, -0.020726, -0.022834, -0.0249, -0.026914, -0.028863, 
                    -0.030732, -0.032506, -0.034165, -0.035691, -0.037067, -0.038285, -0.039414, -0.040428, 
                    -0.041279, -0.041923, -0.042321, -0.042436, -0.042237, -0.041705, -0.040845, -0.039699, 
                    -0.038346, -0.03689, -0.035417, -0.033984, -0.032615, -0.031316, -0.030084, -0.02891, -0.027787, 
                    -0.026708, -0.025665, -0.024651, -0.023662, -0.022692, -0.021738, -0.020796, -0.019862, -0.018933, 
                    -0.018007, -0.017081, -0.016153, -0.015221, -0.014283, -0.013337, -0.012383, -0.011418, -0.010444, 
                    -0.009459, -0.008465, -0.007463, -0.006455, -0.005443, -0.00443, -0.003421, -0.002418, -0.001425, 
                    -0.00045, 0.000514, 0.001493, 0.002495, 0.003511, 0.004541, 0.005582, 0.006633, 0.007694, 0.008762, 
                    0.009838, 0.010923, 0.012016, 0.01312, 0.014236, 0.015366, 0.016512, 0.017678, 
                        0.018866, 0.020081, 0.021327, 0.02261, 0.023934, 0.025308, 0.026739, 0.028238, 0.029816, 
                        0.031487, 0.033267, 0.035178, 0.037242, 0.039488, 0.041945, 0.044643, 0.047598, 0.050804, 
                        0.054214, 0.057733, 0.061233, 0.06459, 0.0677, 0.070494, 0.072929, 0.074979, 0.07663, 0.077878, 
                        0.078719, 0.079155, 0.079191, 0.078827, 0.07806, 0.07691, 0.075436, 0.073654, 0.071578, 0.06922, 
                        0.066591, 0.063702, 0.060562, 0.05718, 0.053564, 0.04972, 0.045657, 0.041379, 0.036895, 0.032222, 
                        0.027415, 0.02265, 0.01834, 0.01491, 0.012384, 0.010519, 0.009091, 0.007952, 0.007013, 0.006219, 0.005532, 
                        0.004929, 0.004392, 0.003908, 0.003468, 0.003064, 0.002692, 0.002347, 0.002025, 0.001724, 0.00144, 0.00126])
    
    elif name == "NACA2404":

        XB = np.array([1.000000000000000, 0.999575000000000, 0.998801000000000, 0.997760000000000, 0.996226000000000, 0.993493000000000, 
                       0.986707000000000, 0.973320000000000, 0.958786000000000, 0.944236000000000, 0.929687000000000, 0.915138000000000, 
                       0.900591000000000, 0.886044000000000, 0.871498000000000, 0.856952000000000, 0.842407000000000, 0.827862000000000, 
                       0.813317000000000, 0.798772000000000, 0.784227000000000, 0.769682000000000, 0.755137000000000, 0.740592000000000, 
                       0.726046000000000, 0.711500000000000, 0.696953000000000, 0.682405000000000, 0.667857000000000, 0.653308000000000, 
                       0.638757000000000, 0.624206000000000, 0.609653000000000, 0.595099000000000, 0.580543000000000, 0.565986000000000, 
                       0.551426000000000, 0.536865000000000, 0.522301000000000, 0.507735000000000, 0.493167000000000, 0.478595000000000, 
                       0.464021000000000, 0.449443000000000, 0.434863000000000, 0.420278000000000, 0.405689000000000, 0.391170000000000, 
                       0.376690000000000, 0.362205000000000, 0.347715000000000, 0.333220000000000, 0.318719000000000, 0.304211000000000, 
                       0.289696000000000, 0.275174000000000, 0.260642000000000, 0.246100000000000, 0.231547000000000, 0.216980000000000, 
                       0.202399000000000, 0.187813000000000, 0.173244000000000, 0.158700000000000, 0.144187000000000, 0.129711000000000, 
                       0.115282000000000, 0.100915000000000, 0.086633000000000, 0.072473000000000, 0.058498000000000, 0.044832000000000, 
                       0.031736000000000, 0.019928000000000, 0.011464000000000, 0.007107000000000, 0.004793000000000, 0.003340000000000, 
                       0.002322000000000, 0.001564000000000, 0.000986000000000, 0.000549000000000, 0.000241000000000, 0.000060000000000, 
                       0.000000000000000, 0.000046000000000, 0.000202000000000, 0.000472000000000, 0.000862000000000, 0.001391000000000, 
                       0.002104000000000, 0.003092000000000, 0.004555000000000, 0.007004000000000, 0.011820000000000, 0.020716000000000, 
                       0.032277000000000, 0.044893000000000, 0.058029000000000, 0.071467000000000, 0.085098000000000, 0.098863000000000, 
                       0.112725000000000, 0.126662000000000, 0.140657000000000, 0.154699000000000, 0.168780000000000, 0.182894000000000, 
                       0.197036000000000, 0.211201000000000, 0.225387000000000, 0.239591000000000, 0.253811000000000, 0.268045000000000, 
                       0.282292000000000, 0.296549000000000, 0.310816000000000, 0.325092000000000, 0.339375000000000, 0.353665000000000, 
                       0.367960000000000, 0.382261000000000, 0.396566000000000, 0.410960000000000, 0.425386000000000, 0.439815000000000, 
                       0.454248000000000, 0.468682000000000, 0.483119000000000, 0.497558000000000, 0.511998000000000, 0.526439000000000, 
                       0.540882000000000, 0.555325000000000, 0.569769000000000, 0.584213000000000, 0.598657000000000, 0.613101000000000, 
                       0.627545000000000, 0.641988000000000, 0.656430000000000, 0.670872000000000, 0.685312000000000, 0.699752000000000, 
                       0.714189000000000, 0.728626000000000, 0.743060000000000, 0.757493000000000, 0.771923000000000, 0.786351000000000, 
                       0.800776000000000, 0.815199000000000, 0.829619000000000, 0.844036000000000, 0.858450000000000, 0.872860000000000, 
                       0.887267000000000, 0.901670000000000, 0.916069000000000, 0.930464000000000, 0.944855000000000, 0.959241000000000, 
                       0.973606000000000, 0.986828000000000, 0.993539000000000, 0.996250000000000, 0.997775000000000, 0.998808000000000, 
                       0.999578000000000, 1.000000000000000])

        YB = np.array([-0.000420000000000, -0.000412000000000, -0.000396000000000, -0.000376000000000, -0.000345000000000, -0.000292000000000, 
                       -0.000160000000000, 0.000092000000000, 0.000353000000000, 0.000603000000000, 0.000841000000000, 0.001066000000000, 0.001277000000000, 
                       0.001475000000000, 0.001660000000000, 0.001831000000000, 0.001989000000000, 0.002132000000000, 0.002261000000000, 0.002377000000000, 
                       0.002478000000000, 0.002565000000000, 0.002638000000000, 0.002697000000000, 0.002741000000000, 0.002772000000000, 0.002789000000000, 
                       0.002793000000000, 0.002783000000000, 0.002760000000000, 0.002724000000000, 0.002675000000000, 0.002614000000000, 0.002541000000000, 
                       0.002456000000000, 0.002360000000000, 0.002253000000000, 0.002136000000000, 0.002009000000000, 0.001873000000000, 0.001729000000000, 
                       0.001577000000000, 0.001418000000000, 0.001252000000000, 0.001081000000000, 0.000906000000000, 0.000727000000000, 0.000541000000000, 
                       0.000328000000000, 0.000085000000000, -0.000186000000000, -0.000483000000000, -0.000805000000000, -0.001151000000000, -0.001519000000000, 
                       -0.001906000000000, -0.002311000000000, -0.002731000000000, -0.003163000000000, -0.003604000000000, -0.004051000000000, -0.004500000000000, 
                       -0.004944000000000, -0.005378000000000, -0.005794000000000, -0.006184000000000, -0.006538000000000, -0.006842000000000, -0.007077000000000, 
                       -0.007220000000000, -0.007236000000000, -0.007075000000000, -0.006662000000000, -0.005910000000000, -0.004930000000000, -0.004119000000000, 
                       -0.003512000000000, -0.003014000000000, -0.002571000000000, -0.002153000000000, -0.001741000000000, -0.001323000000000, -0.000892000000000, 
                       -0.000451000000000, -0.000023000000000, 0.000405000000000, 0.000859000000000, 0.001325000000000, 0.001807000000000, 0.002318000000000, 0.002880000000000,
                         0.003531000000000, 0.004344000000000, 0.005484000000000, 0.007313000000000, 0.010013000000000, 0.012881000000000, 0.015551000000000, 0.017998000000000, 
                         0.020243000000000, 0.022307000000000, 0.024209000000000, 0.025965000000000, 0.027584000000000, 0.029077000000000, 0.030451000000000, 0.031713000000000, 
                         0.032867000000000, 0.033918000000000, 0.034870000000000, 0.035726000000000, 0.036490000000000, 0.037163000000000, 0.037749000000000, 0.038250000000000, 
                         0.038667000000000, 0.039003000000000, 0.039258000000000, 0.039435000000000, 0.039535000000000, 0.039558000000000, 0.039508000000000, 0.039384000000000, 
                         0.039195000000000, 0.038961000000000, 0.038684000000000, 0.038366000000000, 0.038007000000000, 0.037607000000000, 0.037169000000000, 0.036692000000000, 
                         0.036178000000000, 0.035626000000000, 0.035037000000000, 0.034412000000000, 0.033751000000000, 0.033055000000000, 0.032325000000000, 0.031560000000000, 
                         0.030761000000000, 0.029928000000000, 0.029061000000000, 0.028162000000000, 0.027229000000000, 0.026264000000000, 0.025266000000000, 0.024236000000000, 
                         0.023173000000000, 0.022078000000000, 0.020951000000000, 0.019792000000000, 0.018600000000000, 0.017377000000000, 0.016121000000000, 0.014833000000000, 
                         0.013513000000000, 0.012160000000000, 0.010775000000000, 0.009357000000000, 0.007906000000000, 0.006422000000000, 0.004904000000000, 0.003356000000000, 
                         0.001900000000000, 0.001149000000000, 0.000844000000000, 0.000672000000000, 0.000555000000000, 0.000468000000000, 0.000420000000000])

    elif name == "NACA0012":

        XB = np.array([1.000000000000000, 0.999114000000000, 0.997716000000000, 0.996227000000000, 0.994633000000000, 0.992920000000000, 0.991068000000000, 0.989055000000000, 0.986850000000000,
                        0.984417000000000, 0.981703000000000, 0.978642000000000, 0.975137000000000, 0.971053000000000, 0.966184000000000, 0.960208000000000, 0.952593000000000, 0.942439000000000, 
                        0.928274000000000, 0.908355000000000, 0.882502000000000, 0.853080000000000, 0.822345000000000, 0.791230000000000, 0.760014000000000, 0.728790000000000, 0.697601000000000, 
                        0.666483000000000, 0.635466000000000, 0.604582000000000, 0.573864000000000, 0.543344000000000, 0.513057000000000, 0.483038000000000, 0.453323000000000, 0.423952000000000, 
                        0.394967000000000, 0.366413000000000, 0.338340000000000, 0.310806000000000, 0.283875000000000, 0.257627000000000, 0.232154000000000, 0.207576000000000, 0.184045000000000, 
                        0.161764000000000, 0.141001000000000, 0.122073000000000, 0.105290000000000, 0.090830000000000, 0.078657000000000, 0.068532000000000, 0.060121000000000, 0.053087000000000, 
                        0.047141000000000, 0.042054000000000, 0.037651000000000, 0.033796000000000, 0.030389000000000, 0.027352000000000, 0.024625000000000, 0.022159000000000, 0.019920000000000, 
                        0.017875000000000, 0.016002000000000, 0.014282000000000, 0.012698000000000, 0.011238000000000, 0.009891000000000, 0.008648000000000, 0.007504000000000, 0.006451000000000, 
                        0.005486000000000, 0.004605000000000, 0.003806000000000, 0.003087000000000, 0.002447000000000, 0.001884000000000, 0.001397000000000, 0.000986000000000, 0.000650000000000, 
                        0.000386000000000, 0.000193000000000, 0.000068000000000, 0.000007000000000, 0.000007000000000, 0.000068000000000, 0.000193000000000, 0.000386000000000, 0.000650000000000, 
                        0.000986000000000, 0.001397000000000, 0.001884000000000, 0.002447000000000, 0.003087000000000, 0.003806000000000, 0.004605000000000, 0.005486000000000, 0.006451000000000, 
                        0.007504000000000, 0.008648000000000, 0.009891000000000, 0.011238000000000, 0.012698000000000, 0.014282000000000, 0.016002000000000, 0.017875000000000, 0.019920000000000, 
                        0.022159000000000, 0.024625000000000, 0.027352000000000, 0.030389000000000, 0.033796000000000, 0.037651000000000, 0.042054000000000, 0.047141000000000, 0.053087000000000, 
                        0.060121000000000, 0.068532000000000, 0.078657000000000, 0.090830000000000, 0.105290000000000, 0.122073000000000, 0.141001000000000, 0.161764000000000, 0.184045000000000, 
                        0.207576000000000, 0.232154000000000, 0.257627000000000, 0.283875000000000, 0.310806000000000, 0.338340000000000, 0.366413000000000, 0.394967000000000, 0.423952000000000, 
                        0.453323000000000, 0.483038000000000, 0.513057000000000, 0.543344000000000, 0.573864000000000, 0.604582000000000, 0.635466000000000, 0.666483000000000, 0.697601000000000, 
                        0.728790000000000, 0.760014000000000, 0.791230000000000, 0.822345000000000, 0.853080000000000, 0.882502000000000, 0.908355000000000, 0.928274000000000, 0.942439000000000, 
                        0.952593000000000, 0.960208000000000, 0.966184000000000, 0.971053000000000, 0.975137000000000, 0.978642000000000, 0.981703000000000, 0.984417000000000, 0.986850000000000, 
                        0.989055000000000, 0.991068000000000, 0.992920000000000, 0.994633000000000, 0.996227000000000, 0.997716000000000, 0.999114000000000, 1.000000000000000])

        YB = np.array([-0.001260000000000, -0.001384000000000, -0.001580000000000, -0.001788000000000, -0.002011000000000, -0.002249000000000, -0.002506000000000, -0.002785000000000, -0.003090000000000, 
                       -0.003426000000000, -0.003799000000000, -0.004218000000000, -0.004696000000000, -0.005250000000000, -0.005908000000000, -0.006709000000000, -0.007723000000000, -0.009060000000000, 
                       -0.010898000000000, -0.013432000000000, -0.016634000000000, -0.020163000000000, -0.023723000000000, -0.027198000000000, -0.030554000000000, -0.033781000000000, -0.036872000000000, 
                       -0.039820000000000, -0.042618000000000, -0.045255000000000, -0.047723000000000, -0.050008000000000, -0.052098000000000, -0.053979000000000, -0.055636000000000, -0.057053000000000, 
                       -0.058214000000000, -0.059102000000000, -0.059699000000000, -0.059990000000000, -0.059958000000000, -0.059589000000000, -0.058869000000000, -0.057792000000000, -0.056357000000000, 
                       -0.054578000000000, -0.052492000000000, -0.050165000000000, -0.047697000000000, -0.045204000000000, -0.042790000000000, -0.040516000000000, -0.038408000000000, -0.036462000000000, 
                       -0.034663000000000, -0.032992000000000, -0.031429000000000, -0.029959000000000, -0.028567000000000, -0.027240000000000, -0.025967000000000, -0.024741000000000, -0.023554000000000, 
                       -0.022399000000000, -0.021272000000000, -0.020167000000000, -0.019080000000000, -0.018008000000000, -0.016948000000000, -0.015897000000000, -0.014852000000000, -0.013811000000000, 
                       -0.012773000000000, -0.011736000000000, -0.010700000000000, -0.009663000000000, -0.008625000000000, -0.007588000000000, -0.006552000000000, -0.005519000000000, -0.004491000000000, 
                       -0.003470000000000, -0.002460000000000, -0.001461000000000, -0.000483000000000, 0.000483000000000, 0.001461000000000, 0.002459000000000, 0.003470000000000, 0.004491000000000, 0.005519000000000, 
                       0.006552000000000, 0.007588000000000, 0.008625000000000, 0.009663000000000, 0.010700000000000, 0.011736000000000, 0.012773000000000, 0.013811000000000, 0.014852000000000, 0.015897000000000, 
                       0.016948000000000, 0.018008000000000, 0.019080000000000, 0.020167000000000, 0.021272000000000, 0.022399000000000, 0.023554000000000, 0.024741000000000, 0.025967000000000, 0.027239000000000, 
                       0.028567000000000, 0.029959000000000, 0.031429000000000, 0.032992000000000, 0.034663000000000, 0.036462000000000, 0.038408000000000, 0.040516000000000, 0.042790000000000, 0.045204000000000, 
                       0.047697000000000, 0.050165000000000, 0.052492000000000, 0.054578000000000, 0.056357000000000, 0.057792000000000, 0.058869000000000, 0.059589000000000, 0.059958000000000, 0.059990000000000, 
                       0.059699000000000, 0.059102000000000, 0.058214000000000, 0.057053000000000, 0.055636000000000, 0.053979000000000, 0.052098000000000, 0.050008000000000, 0.047723000000000, 0.045255000000000, 
                       0.042618000000000, 0.039820000000000, 0.036872000000000, 0.033781000000000, 0.030554000000000, 0.027198000000000, 0.023723000000000, 0.020163000000000, 0.016634000000000, 0.013432000000000, 
                       0.010898000000000, 0.009060000000000, 0.007723000000000, 0.006709000000000, 0.005908000000000, 0.005250000000000, 0.004696000000000, 0.004218000000000, 0.003799000000000, 0.003426000000000, 
                       0.003090000000000, 0.002785000000000, 0.002506000000000, 0.002249000000000, 0.002011000000000, 0.001788000000000, 0.001580000000000, 0.001384000000000, 0.001260000000000])

    elif name == "NACA4520":

        XB = np.array([1.000000000000000, 0.998275000000000, 0.995582000000000, 0.992750000000000, 0.989764000000000, 0.986605000000000, 0.983254000000000, 0.979688000000000, 0.975876000000000, 0.971785000000000, 
                       0.967371000000000, 0.962583000000000, 0.957355000000000, 0.951601000000000, 0.945213000000000, 0.938045000000000, 0.929897000000000, 0.920492000000000, 0.909426000000000, 0.896099000000000, 
                       0.879590000000000, 0.858471000000000, 0.830654000000000, 0.793741000000000, 0.746726000000000, 0.691563000000000, 0.631290000000000, 0.567955000000000, 0.504344000000000, 0.444844000000000, 
                       0.391375000000000, 0.344275000000000, 0.303372000000000, 0.268259000000000, 0.238359000000000, 0.212981000000000, 0.191409000000000, 0.172970000000000, 0.157085000000000, 0.143276000000000, 
                       0.131159000000000, 0.120429000000000, 0.110849000000000, 0.102228000000000, 0.094417000000000, 0.087295000000000, 0.080765000000000, 0.074749000000000, 0.069182000000000, 0.064011000000000, 
                       0.059191000000000, 0.054686000000000, 0.050463000000000, 0.046497000000000, 0.042765000000000, 0.039248000000000, 0.035931000000000, 0.032799000000000, 0.029841000000000, 0.027048000000000, 
                       0.024411000000000, 0.021924000000000, 0.019581000000000, 0.017379000000000, 0.015315000000000, 0.013386000000000, 0.011592000000000, 0.009930000000000, 0.008401000000000, 0.007005000000000, 
                       0.005742000000000, 0.004610000000000, 0.003611000000000, 0.002741000000000, 0.001999000000000, 0.001381000000000, 0.000885000000000, 0.000505000000000, 0.000235000000000, 0.000069000000000, 
                       0.000002000000000, 0.000027000000000, 0.000145000000000, 0.000359000000000, 0.000674000000000, 0.001091000000000, 0.001614000000000, 0.002245000000000, 0.002986000000000, 0.003839000000000, 
                       0.004805000000000, 0.005886000000000, 0.007086000000000, 0.008405000000000, 0.009847000000000, 0.011415000000000, 0.013113000000000, 0.014945000000000, 0.016918000000000, 0.019036000000000, 
                       0.021307000000000, 0.023740000000000, 0.026344000000000, 0.029130000000000, 0.032112000000000, 0.035304000000000, 0.038723000000000, 0.042389000000000, 0.046324000000000, 0.050554000000000, 
                       0.055110000000000, 0.060026000000000, 0.065342000000000, 0.071103000000000, 0.077364000000000, 0.084186000000000, 0.091638000000000, 0.099802000000000, 0.108768000000000, 0.118637000000000, 
                       0.129519000000000, 0.141531000000000, 0.154791000000000, 0.169412000000000, 0.185497000000000, 0.203125000000000, 0.222350000000000, 0.243192000000000, 0.265643000000000, 0.289672000000000, 
                       0.315230000000000, 0.342256000000000, 0.370690000000000, 0.400466000000000, 0.431517000000000, 0.463774000000000, 0.497158000000000, 0.531577000000000, 0.566921000000000, 0.603046000000000, 
                       0.639755000000000, 0.676755000000000, 0.713580000000000, 0.749481000000000, 0.783370000000000, 0.813993000000000, 0.840438000000000, 0.862538000000000, 0.880759000000000, 0.895822000000000, 
                       0.908416000000000, 0.919101000000000, 0.928300000000000, 0.936330000000000, 0.943425000000000, 0.949761000000000, 0.955472000000000, 0.960661000000000, 0.965411000000000, 0.969784000000000, 
                       0.973833000000000, 0.977601000000000, 0.981121000000000, 0.984423000000000, 0.987530000000000, 0.990465000000000, 0.993243000000000, 0.995881000000000, 0.998391000000000, 1.000000000000000 ])

        YB = np.array([-0.002100000000000, -0.002227000000000, -0.002427000000000, -0.002636000000000, -0.002858000000000, -0.003092000000000, -0.003341000000000, -0.003607000000000, -0.003892000000000, -0.004198000000000, 
                       -0.004529000000000, -0.004890000000000, -0.005285000000000, -0.005721000000000, -0.006208000000000, -0.006757000000000, -0.007385000000000, -0.008115000000000, -0.008982000000000, -0.010039000000000, 
                       -0.011369000000000, -0.013103000000000, -0.015448000000000, -0.018675000000000, -0.022978000000000, -0.028296000000000, -0.034397000000000, -0.041036000000000, -0.047776000000000, -0.053934000000000, 
                       -0.059121000000000, -0.063209000000000, -0.066210000000000, -0.068228000000000, -0.069419000000000, -0.069953000000000, -0.069989000000000, -0.069658000000000, -0.069059000000000, -0.068265000000000, 
                       -0.067329000000000, -0.066287000000000, -0.065165000000000, -0.063981000000000, -0.062749000000000, -0.061478000000000, -0.060173000000000, -0.058840000000000, -0.057481000000000, -0.056098000000000, 
                       -0.054691000000000, -0.053262000000000, -0.051811000000000, -0.050337000000000, -0.048839000000000, -0.047316000000000, -0.045768000000000, -0.044193000000000, -0.042591000000000, -0.040959000000000, 
                       -0.039296000000000, -0.037602000000000, -0.035875000000000, -0.034114000000000, -0.032319000000000, -0.030489000000000, -0.028625000000000, -0.026727000000000, -0.024797000000000, -0.022837000000000, 
                       -0.020849000000000, -0.018837000000000, -0.016805000000000, -0.014758000000000, -0.012701000000000, -0.010639000000000, -0.008579000000000, -0.006524000000000, -0.004482000000000, -0.002454000000000, 
                       -0.000451000000000, 0.001546000000000, 0.003577000000000, 0.005640000000000, 0.007729000000000, 0.009845000000000, 0.011983000000000, 0.014142000000000, 0.016321000000000, 0.018518000000000, 0.020731000000000, 
                       0.022961000000000, 0.025207000000000, 0.027469000000000, 0.029747000000000, 0.032043000000000, 0.034357000000000, 0.036691000000000, 0.039047000000000, 0.041427000000000, 0.043833000000000, 0.046268000000000, 
                       0.048735000000000, 0.051237000000000, 0.053777000000000, 0.056360000000000, 0.058990000000000, 0.061671000000000, 0.064407000000000, 0.067203000000000, 0.070066000000000, 0.072999000000000, 0.076008000000000, 
                       0.079100000000000, 0.082277000000000, 0.085546000000000, 0.088908000000000, 0.092365000000000, 0.095915000000000, 0.099551000000000, 0.103261000000000, 0.107025000000000, 0.110812000000000, 0.114579000000000, 
                       0.118271000000000, 0.121819000000000, 0.125144000000000, 0.128160000000000, 0.130778000000000, 0.132911000000000, 0.134479000000000, 0.135408000000000, 0.135634000000000, 0.135103000000000, 0.133766000000000, 
                       0.131586000000000, 0.128530000000000, 0.124577000000000, 0.119713000000000, 0.113939000000000, 0.107274000000000, 0.099772000000000, 0.091543000000000, 0.082803000000000, 0.073910000000000, 0.065339000000000, 
                       0.057528000000000, 0.050707000000000, 0.044881000000000, 0.039926000000000, 0.035685000000000, 0.032017000000000, 0.028807000000000, 0.025966000000000, 0.023424000000000, 0.021130000000000, 0.019042000000000, 
                       0.017128000000000, 0.015362000000000, 0.013725000000000, 0.012199000000000, 0.010770000000000, 0.009428000000000, 0.008162000000000, 0.006964000000000, 0.005828000000000, 0.004747000000000, 0.003717000000000, 
                       0.002733000000000, 0.002100000000000])

    else:
        XB = 0
        YB = 0
    return XB, YB


def plotSourceCylinder(alpha, panels, V):
    # User-defined knowns
    Vinf = V                                                                        # Freestream velocity
    AoA  = alpha                                                                    # Angle of attack [deg]
    numB = panels+1                                                             # Number of boundary points (including endpoint)
    tO   = (360/(numB-1))/2                                                         # Boundary point angle offset [deg]
    AoAR = AoA*(np.pi/180)                                                          # Convert AoA to radians [rad]

    # %% CREATE CIRCLE BOUNDARY POINTS

    # Angles used to compute boundary points
    theta = np.linspace(0,360,numB)                                                 # Create angles for computing boundary point locations [deg]
    theta = theta + tO                                                              # Add panel angle offset [deg]
    theta = theta*(np.pi/180)                                                       # Convert from degrees to radians [rad]

    # Boundary points
    XB = np.cos(theta)                                                              # Compute boundary point X-coordinate [radius of 1]
    YB = np.sin(theta)                                                              # Compute boundary point Y-coordinate [radius of 1]

    # Number of panels
    numPan = len(XB)-1                                                              # Number of panels (control points)

    # %% CHECK PANEL DIRECTIONS - FLIP IF NECESSARY

    # Check for direction of points
    edge = np.zeros(numPan)                                                         # Initialize edge value array
    for i in range(numPan):                                                         # Loop over all panels
        edge[i] = (XB[i+1]-XB[i])*(YB[i+1]+YB[i])                                   # Compute edge values

    sumEdge = np.sum(edge)                                                          # Sum of all edge values

    # If panels are CCW, flip them (don't if CW)
    if (sumEdge < 0):                                                               # If panels are CCW
        XB = np.flipud(XB)                                                          # Flip the X-data array
        YB = np.flipud(YB)                                                          # Flip the Y-data array

    # %% PANEL METHOD GEOMETRY - REF [1]

    # Initialize variables
    XC  = np.zeros(numPan)                                                          # Initialize control point X-coordinate
    YC  = np.zeros(numPan)                                                          # Initialize control point Y-coordinate
    S   = np.zeros(numPan)                                                          # Initialize panel length array
    phi = np.zeros(numPan)                                                          # Initialize panel orientation angle array

    # Find geometric quantities of the airfoil
    for i in range(numPan):                                                         # Loop over all panels
        XC[i]   = 0.5*(XB[i]+XB[i+1])                                               # X-value of control point
        YC[i]   = 0.5*(YB[i]+YB[i+1])                                               # Y-value of control point
        dx      = XB[i+1]-XB[i]                                                     # Change in X between boundary points
        dy      = YB[i+1]-YB[i]                                                     # Change in Y between boundary points
        S[i]    = (dx**2 + dy**2)**0.5                                              # Length of the panel
        phi[i]  = math.atan2(dy,dx)                                                 # Angle of panel (positive X-axis to inside face)
        if (phi[i] < 0):                                                            # Make all panel angles positive [rad]
            phi[i] = phi[i] + 2*np.pi

    # Compute angle of panel normal w.r.t. horizontal and include AoA
    delta                = phi + (np.pi/2)                                          # Angle of panel normal [rad]
    beta                 = delta - AoAR                                             # Angle of panel normal and AoA [rad]
    beta[beta > 2*np.pi] = beta[beta > 2*np.pi] - 2*np.pi                           # Make all panel angles between 0 and 2pi [rad]

    # %% COMPUTE SOURCE PANEL STRENGTHS - REF [5]

    # Geometric integral (normal [I] and tangential [J])
    # - Refs [2] and [3]
    I, J = COMPUTE_IJ_SPM(XC,YC,XB,YB,phi,S)                                        # Compute geometric integrals

    # Populate A matrix
    # - Simpler option: A = I + np.pi*np.eye(numPan,numPan)
    A = np.zeros([numPan,numPan])                                                   # Initialize the A matrix
    for i in range(numPan):                                                         # Loop over all i panels
        for j in range(numPan):                                                     # Loop over all j panels
            if (i == j):                                                            # If the panels are the same
                A[i,j] = np.pi                                                      # Set A equal to pi
            else:                                                                   # If panels are not the same
                A[i,j] = I[i,j]                                                     # Set A equal to geometric integral

    # Populate b array
    # - Simpler option: b = -Vinf*2*np.pi*np.cos(beta)
    b = np.zeros(numPan)                                                            # Initialize the b array
    for i in range(numPan):                                                         # Loop over all panels
        b[i] = -Vinf*2*np.pi*np.cos(beta[i])                                        # Compute RHS array

    # Compute source panel strengths (lam) from system of equations
    lam = np.linalg.solve(A,b)                                                      # Compute all source strength values

    # %% COMPUTE PANEL VELOCITIES AND PRESSURE COEFFICIENTS

    # Compute velocities
    # - Simpler method: Vt = Vinf*np.sin(beta) + np.dot(J,lam)/(2*np.pi)
    #                   Cp = 1 - (Vt/Vinf)**2
    Vt = np.zeros(numPan)                                                           # Initialize tangential velocity array
    Cp = np.zeros(numPan)                                                           # Initialize pressure coefficient array
    for i in range(numPan):                                                         # Loop over all i panels
        addVal = 0                                                                  # Reset the summation value to zero
        for j in range(numPan):                                                     # Loop over all j panels
            addVal = addVal + (lam[j]/(2*np.pi))*J[i,j]                             # Sum all tangential source panel terms
        
        Vt[i] = Vinf*np.sin(beta[i]) + addVal                                       # Compute tangential velocity by adding uniform flow term
        Cp[i] = 1 - (Vt[i]/Vinf)**2                                                 # Compute pressure coefficient

    # Analytical angles and pressure coefficients
    analyticTheta = np.linspace(0,2*np.pi,200)                                      # Analytical theta angles [rad]
    analyticCP    = 1 - 4*np.sin(analyticTheta)**2                                  # Analytical pressure coefficient []

    # %% COMPUTE STREAMLINES - REF [4]

    # Grid parameters
    nGridX   = 40                                                              # X-grid for streamlines and contours
    nGridY   = 40                                                              # Y-grid for streamlines and contours
    xVals    = [-1.5, 1.5]                                                      # X-grid extents [min, max]
    yVals    = [-1.5, 1.5]                                                      # Y-grid extents [min, max]
        
    # Generate the grid points
    Xgrid  = np.linspace(xVals[0],xVals[1],nGridX)                              # X-values in evenly spaced grid
    Ygrid  = np.linspace(yVals[0],yVals[1],nGridY)                              # Y-values in evenly spaced grid
    XX, YY = np.meshgrid(Xgrid, Ygrid)                                          # Create meshgrid from X and Y grid arrays
        
    # Initialize velocities
    Vx     = np.zeros([nGridX,nGridY])                                          # Initialize X velocity matrix
    Vy     = np.zeros([nGridX,nGridY])                                          # Initialize Y velocity matrix
        
    # Path to figure out if grid point is inside polygon or not
    AF     = np.vstack((XB.T,YB.T)).T                                           # Concatenate XB and YB geometry points
    afPath = path.Path(AF)                                                      # Create a path for the geometry
        
    # Solve for grid point X and Y velocities
    for m in range(nGridX):                                                     # Loop over X-grid points
        for n in range(nGridY):                                                 # Loop over Y-grid points
            XP     = XX[m,n]                                                    # Isolate X point
            YP     = YY[m,n]                                                    # Isolate Y point
            Mx, My = STREAMLINE_SPM(XP,YP,XB,YB,phi,S)                          # Compute streamline Mx and My values (Ref [4])
                
            # Check if grid points are in object
            # - If they are, assign a velocity of zero
            if afPath.contains_points([(XP,YP)]):                               # If (XP,YP) is in the polygon body
                Vx[m,n] = 0.0007                                                    # X-velocity is zero
                Vy[m,n] = 0.0007                                                   # Y-velocity is zero
            else:                                                               # If (XP,YP) is not in the polygon body
                Vx[m,n] = Vinf*np.cos(AoAR) + sum(lam*Mx/(2*np.pi))             # Compute X-velocity
                Vy[m,n] = Vinf*np.sin(AoAR) + sum(lam*My/(2*np.pi))             # Compute Y-velocity
        
    # Compute grid point velocity magnitude and pressure coefficient
    Vxy  = np.sqrt(Vx**2 + Vy**2)                                               # Compute magnitude of velocity vector
    CpXY = 1 - (Vxy/Vinf)**2                                                    # Pressure coefficient []


    ## ========================== ##
    ## ADD INFORMATION TO FIGUREs ##
    ## ========================== ##

    fig1 = make_subplots(rows=2, cols=2,
                         subplot_titles=("Panel Geometry", "Surface Pressure Distribution", "Pressure Field", "Airflow streamlines"), 
                         horizontal_spacing=0.3
                        )
    
    #Add plots
    fig1.add_trace(go.Scatter(
                name="Complete Panel Geometry",
                x=XB, y=YB,
                mode="lines",  #Plot as a line
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    fig1.add_trace(go.Scatter(
                name="Panel Boundary Points",
                x=XB, y=YB,
                mode='markers',  #Plot as a point
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    fig1.add_trace(go.Scatter(
                name="Panel Control Points",
                x=XC, y=YC,
                mode="markers",  #Plot as a point
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    fig1.add_trace(go.Scatter(
                name="Analytical Surface Pressure Distribution",
                x=analyticTheta*(180/np.pi), y=analyticCP,
                mode='lines',  #Plot as a line
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=2)
    
    fig1.add_trace(go.Scatter(
                name="Numerical Surface Pressure Distribution",
                x=beta*(180/np.pi), y=Cp,
                mode='markers',  #Plot as a point
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=2)
    
    fig1.add_trace(go.Contour(name="Pressure Field",
                              x=Xgrid, y=Ygrid, z=CpXY,
                              colorscale="RdBu_r", zmin=np.min(CpXY), zmax=np.max(CpXY),
                              contours=dict(start=np.min(CpXY),
                                            end  = np.max(CpXY),
                                            size = abs(np.min(CpXY) + np.max(CpXY)) / 100,
                                           ),
                              contours_showlines=False,
                              showscale=False,
                              hovertemplate='x = %{x:.4f}'+
                                            '<br>y = %{y:.4f}'+
                                            '<br>Cp = %{z:.4e}'+
                                            '<extra></extra>', ## '<extra></extra>' removes the trace name from hover text
                             ),
                   row=2, col=1
                  )
    
    #Append streamline
    Vx = np.where(Vx == 0, np.nan, Vx)
    Vy = np.where(Vy == 0, np.nan, Vy)
    streamlines = ff.create_streamline(Xgrid, Ygrid,
                                        Vx, Vy,
                                        density=1,
                                        arrow_scale=0.1,
                                        hoverinfo='skip',
                                        name='streamlines',
                                        line=dict(color='rgba(0,0,0,1)', width=0.75)
                                        )
    for t in streamlines.data:
        fig1.append_trace(t, row=2, col=2)
  
    
    fig1.add_trace(go.Contour(name="Velocity Field",
                              x=Xgrid, y=Ygrid, z=Vxy,
                              colorscale="RdBu_r", zmin=np.min(Vxy), zmax=np.max(Vxy),
                              contours=dict(start=np.min(Vxy),
                                            end  = np.max(Vxy),
                                            size = (np.min(Vxy) + np.max(Vxy)) / 100,
                                           ), 
                              contours_showlines=False,
                              showscale=False,
                              hovertemplate='x = %{x:.4f}'+
                                            '<br>y = %{y:.4f}'+
                                            '<br>Vmag = %{z:.4e}'+
                                            '<extra></extra>', ## '<extra></extra>' removes the trace name from hover text
                             ),
                   row=2, col=2
                  )

    fig1.add_trace(go.Scatter(
                name="Cylinder",
                x=XB, y=YB,
                mode="lines",  #Plot as a line
                fill="toself",
                fillcolor="black",  # Solid black color
                line=dict(color="black"),  # Line color, optional
                opacity=1 , # Fully opaque,
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=[2, 2], col=[1, 2])

    #Update x-axis properties
    fig1.update_xaxes(#title_text='x',
                      title_font_color='#000000',
                      title_standoff=0,
                      gridcolor='rgba(153, 153, 153, 0.75)', #999999 in RGB
                      gridwidth=1,
                      zerolinecolor='#000000',
                      zerolinewidth=2,
                      linecolor='#000000',
                      linewidth=1,
                      ticks='outside',
                      ticklen=10,
                      tickwidth=2,
                      tickcolor='#000000',
                      tickfont_color='#000000',
                      minor_showgrid=True,
                      minor_gridcolor='rgba(221, 221, 221, 0.50)', #DDDDDD in RGB, 0.50 opacity
                      minor_ticks='outside',
                      minor_ticklen=5,
                      minor_tickwidth=2,
                      minor_griddash='dot',
                      hoverformat='.4f',
                     )
    
    #Update y-axis properties
    fig1.update_yaxes(#title_text='y',
                      title_font_color='#000000',
                      title_standoff=0,
                      gridcolor='rgba(153, 153, 153, 0.75)', #999999 in RGB, 0.75 opacity
                      gridwidth=1,
                      zerolinecolor='#000000',
                      zerolinewidth=2,
                      linecolor='#000000',
                      linewidth=1,
                      ticks='outside',
                      ticklen=10,
                      tickwidth=2,
                      tickcolor='#000000',
                      tickfont_color='#000000',
                      minor_showgrid=True,
                      minor_gridcolor='rgba(221, 221, 221, 0.50)', #DDDDDD in RGB, 0.50 opacity
                      minor_ticks='outside',
                      minor_ticklen=5,
                      minor_tickwidth=2,
                      minor_griddash='dot',

                     )

    fig1.update_xaxes(range=[np.min(Ygrid), np.max(Ygrid)], scaleanchor="x", row=1, col=1)
    fig1.update_yaxes(range=[np.min(Xgrid), np.max(Xgrid)], scaleanchor="y", row=1, col=1)

    fig1.update_xaxes(range=[np.min(Ygrid), np.max(Ygrid)], scaleanchor="x", row=2, col=1)
    fig1.update_yaxes(range=[np.min(Xgrid), np.max(Xgrid)], scaleanchor="y", row=2, col=1)

    fig1.update_xaxes(range=[np.min(Ygrid), np.max(Ygrid)], scaleanchor="x", row=2, col=2)
    fig1.update_yaxes(range=[np.min(Xgrid), np.max(Xgrid)], scaleanchor="y", row=2, col=2)

    #Update figure layout
    fig1.update_layout(font_color='#000000',
                       plot_bgcolor='rgba(255,255,255,1)',
                       paper_bgcolor='rgba(255,255,255,1)',
                       showlegend=False,
                      )

    return fig1

def plotSourceAirfoil(alpha, V, name):

    # %% KNOWNS

    # User-defined knowns
    Vinf = V                                                                        # Freestream velocity []
    AoA  = alpha                                                                        # Angle of attack [deg]
    
    if name == 1:
        XB, YB = airfoil_storage("NACA0012")
    elif name == 2:
        XB, YB = airfoil_storage("NACA2412")
    elif name == 3:
        XB, YB = airfoil_storage("NACA2404")
    elif name == 4:
        XB, YB = airfoil_storage("NACA4520")

    # Convert angle of attack to radians
    AoAR   = AoA*(np.pi/180)                                                        # Angle of attack [rad]

    # Number of boundary points and panels
    numPts = len(XB)                                                                # Number of boundary points
    numPan = numPts - 1                                                             # Number of panels (control points)

    # %% CHECK PANEL DIRECTIONS - FLIP IF NECESSARY

    # Check for direction of points
    edge = np.zeros(numPan)                                                         # Initialize edge value array
    for i in range(numPan):                                                         # Loop over all panels
        edge[i] = (XB[i+1]-XB[i])*(YB[i+1]+YB[i])                                   # Compute edge values

    sumEdge = np.sum(edge)                                                          # Sum all edge values

    # If panels are CCW, flip them (don't if CW)
    if (sumEdge < 0):                                                               # If panels are CCW
        XB = np.flipud(XB)                                                          # Flip the X-data array
        YB = np.flipud(YB)                                                          # Flip the Y-data array

    # %% PANEL METHOD GEOMETRY - REF [1]
        
    # Initialize variables
    XC  = np.zeros(numPan)                                                          # Initialize control point X-coordinate
    YC  = np.zeros(numPan)                                                          # Initialize control point Y-coordinate
    S   = np.zeros(numPan)                                                          # Initialize panel length array
    phi = np.zeros(numPan)                                                          # Initialize panel orientation angle array [deg]

    # Find geometric quantities of the airfoil
    for i in range(numPan):                                                         # Loop over all panels
        XC[i]   = 0.5*(XB[i]+XB[i+1])                                               # X-value of control point
        YC[i]   = 0.5*(YB[i]+YB[i+1])                                               # Y-value of control point
        dx      = XB[i+1]-XB[i]                                                     # Change in X between boundary points
        dy      = YB[i+1]-YB[i]                                                     # Change in Y between boundary points
        S[i]    = (dx**2 + dy**2)**0.5                                              # Length of the panel
        phi[i]  = math.atan2(dy,dx)                                                 # Angle of panel (positive X-axis to inside face)
        if (phi[i] < 0):                                                            # Make all panel angles positive [rad]
            phi[i] = phi[i] + 2*np.pi

    # Compute angle of panel normal w.r.t. horizontal and include AoA
    delta                = phi + (np.pi/2)                                          # Angle of panel normal [rad]
    beta                 = delta - AoAR                                             # Angle of panel normal and AoA [rad]
    beta[beta > 2*np.pi] = beta[beta > 2*np.pi] - 2*np.pi                           # Make all panel angles between 0 and 2pi [rad]

    # %% COMPUTE SOURCE PANEL STRENGTHS - REF [5]

    # Geometric integral (normal [I] and tangential [J])
    # - Refs [2] and [3]
    I, J = COMPUTE_IJ_SPM(XC,YC,XB,YB,phi,S)                                        # Compute geometric integrals

    # Populate A matrix
    # - Simpler option: A = I + np.pi*np.eye(numPan,numPan)
    A = np.zeros([numPan,numPan])                                                   # Initialize the A matrix
    for i in range(numPan):                                                         # Loop over all i panels
        for j in range(numPan):                                                     # Loop over all j panels
            if (i == j):                                                            # If the panels are the same
                A[i,j] = np.pi                                                      # Set A equal to pi
            else:                                                                   # If panels are not the same
                A[i,j] = I[i,j]                                                     # Set A equal to geometric integral

    # Populate b array
    # - Simpler option: b = -Vinf*2*np.pi*np.cos(beta)
    b = np.zeros(numPan)                                                            # Initialize the b array
    for i in range(numPan):                                                         # Loop over all panels
        b[i] = -Vinf*2*np.pi*np.cos(beta[i])                                        # Compute RHS array

    # Compute source panel strengths (lam) from system of equations
    lam = np.linalg.solve(A,b)                                                      # Compute all source strength values

    # %% COMPUTE PANEL VELOCITIES AND PRESSURE COEFFICIENTS

    # Compute velocities
    # - Simpler method: Vt = Vinf*np.sin(beta) + np.dot(J,lam)/(2*np.pi)
    #                   Cp = 1 - (Vt/Vinf)**2
    Vt = np.zeros(numPan)                                                           # Initialize tangential velocity array
    Cp = np.zeros(numPan)                                                           # Initialize pressure coefficient array
    for i in range(numPan):                                                         # Loop over all i panels
        addVal = 0                                                                  # Reset the summation value to zero
        for j in range(numPan):                                                     # Loop over all j panels
            addVal = addVal + (lam[j]/(2*np.pi))*J[i,j]                             # Sum all tangential source panel terms
        
        Vt[i] = Vinf*np.sin(beta[i]) + addVal                                       # Compute tangential velocity by adding uniform flow term
        Cp[i] = 1 - (Vt[i]/Vinf)**2                                                 # Compute pressure coefficient

    # %% COMPUTE STREAMLINES

    # Grid parameters
    nGridX   = 40                                                              # X-grid for streamlines and contours
    nGridY   = 40                                                              # Y-grid for streamlines and contours
    xVals    = [-0.5, 1.5]                                                      # X-grid extents [min, max]
    yVals    = [-0.5, 0.5]                                                      # Y-grid extents [min, max]
        
    # Generate the grid points
    Xgrid  = np.linspace(xVals[0],xVals[1],nGridX)                              # X-values in evenly spaced grid
    Ygrid  = np.linspace(yVals[0],yVals[1],nGridY)                              # Y-values in evenly spaced grid
    XX, YY = np.meshgrid(Xgrid, Ygrid)                                          # Create meshgrid from X and Y grid arrays
        
    # Initialize velocities
    Vx     = np.zeros([nGridX,nGridY])                                          # Initialize X velocity matrix
    Vy     = np.zeros([nGridX,nGridY])                                          # Initialize Y velocity matrix
        
    # Path to figure out if grid point is inside polygon or not
    AF     = np.vstack((XB.T,YB.T)).T                                           # Concatenate XB and YB geometry points
    afPath = path.Path(AF)                                                      # Create a path for the geometry
        
    # Solve for grid point X and Y velocities
    for m in range(nGridX):                                                     # Loop over X grid points
        for n in range(nGridY):                                                 # Loop over Y grid points
            XP     = XX[m,n]                                                    # Current iteration's X grid point
            YP     = YY[m,n]                                                    # Current iteration's Y grid point
            Mx, My = STREAMLINE_SPM(XP,YP,XB,YB,phi,S)                          # Compute Mx and My geometric integrals
                
            # Check if grid points are in object
            # - If they are, assign a velocity of zero
            if afPath.contains_points([(XP,YP)]):                               # If (XP,YP) is in the body
                Vx[m,n] = 0.0007                                                     # X-velocity is zero
                Vy[m,n] = 0.0007                                                     # Y-velocity is zero
            else:
                Vx[m,n] = Vinf*np.cos(AoAR) + sum(lam*Mx/(2*np.pi))             # Set X-velocity
                Vy[m,n] = Vinf*np.sin(AoAR) + sum(lam*My/(2*np.pi))             # Set Y-velocity
        
    # Compute grid point velocity magnitude and pressure coefficient
    Vxy  = np.sqrt(Vx**2 + Vy**2)                                               # Compute magnitude of velocity vector
    CpXY = 1 - (Vxy/Vinf)**2                                                    # Pressure coefficient []

    ## ========================== ##
    ## ADD INFORMATION TO FIGUREs ##
    ## ========================== ##

    fig1 = make_subplots(rows=2, cols=2,
                         subplot_titles=("Panel Geometry", "Surface Pressure Distribution", "Pressure Field", "Airflow streamlines"), 
                         horizontal_spacing=0.3
                        )
    
    #Add plots
    fig1.add_trace(go.Scatter(
                name="Complete Panel Geometry",
                x=XB, y=YB,
                mode="lines",  #Plot as a line
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    fig1.add_trace(go.Scatter(
                name="Panel Boundary Points",
                x=XB, y=YB,
                mode='markers',  #Plot as a point
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    fig1.add_trace(go.Scatter(
                name="Panel Control Points",
                x=XC, y=YC,
                mode="markers",  #Plot as a point
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    #Separate Cp and Xc into upper and lower for plotting
    midIndS = int(np.floor(len(Cp)/2))
    XC_upper = XC[0:midIndS]
    CP_upper = Cp[0:midIndS] 
    XC_lower = XC[midIndS+1:len(XC)]
    CP_lower = Cp[midIndS+1:len(XC)]                                    

    fig1.add_trace(go.Scatter(
                name="Upper Cp",
                x=XC_upper, y=CP_upper,
                mode='markers',  #Plot as a point
                hovertemplate='Upper Cp<br>' +  
                  'x = %{x:.4f}<br>' +
                  'y = %{y:.4f}' +
                  '<extra></extra>',
                        ), row=1, col=2)
    
    fig1.add_trace(go.Scatter(
                name="Lower Cp",
                x=XC_lower, y=CP_lower,
                mode='markers',  #Plot as a point
                hovertemplate='Lower Cp<br>' + 
                  'x = %{x:.4f}<br>' +
                  'y = %{y:.4f}' +
                  '<extra></extra>',
                        ), row=1, col=2)
    
    fig1.add_trace(go.Contour(name="Pressure Field",
                              x=Xgrid, y=Ygrid, z=CpXY,
                              colorscale="RdBu_r", zmin=np.min(CpXY), zmax=np.max(CpXY),
                              contours=dict(start=np.min(CpXY),
                                            end  = np.max(CpXY),
                                            size = abs(np.min(CpXY) + np.max(CpXY)) / 100,
                                           ),
                              contours_showlines=False,
                              showscale=False,
                              hovertemplate='x = %{x:.4f}'+
                                            '<br>y = %{y:.4f}'+
                                            '<br>Cp = %{z:.4e}'+
                                            '<extra></extra>', ## '<extra></extra>' removes the trace name from hover text
                             ),
                   row=2, col=1
                  )
    
    #Append streamline
    Vx = np.where(Vx == 0, np.nan, Vx)
    Vy = np.where(Vy == 0, np.nan, Vy)
    streamlines = ff.create_streamline(Xgrid, Ygrid,
                                        Vx, Vy,
                                        density=0.8,
                                        arrow_scale=0.05,
                                        hoverinfo='skip',
                                        name='streamlines',
                                        line=dict(color='rgba(0,0,0,1)', width=0.75)
                                        )
    for t in streamlines.data:
        fig1.append_trace(t, row=2, col=2)
  
    
    fig1.add_trace(go.Contour(name="Velocity Field",
                              x=Xgrid, y=Ygrid, z=Vxy,
                              colorscale="RdBu_r", zmin=np.min(Vxy), zmax=np.max(Vxy),
                              contours=dict(start=np.min(Vxy),
                                            end  = np.max(Vxy),
                                            size = (np.min(Vxy) + np.max(Vxy)) / 100,
                                           ), 
                              contours_showlines=False,
                              showscale=False,
                              hovertemplate='x = %{x:.4f}'+
                                            '<br>y = %{y:.4f}'+
                                            '<br>Vmag = %{z:.4e}'+
                                            '<extra></extra>', ## '<extra></extra>' removes the trace name from hover text
                             ),
                   row=2, col=2
                  )

    fig1.add_trace(go.Scatter(
                name="Airfoil",
                x=XB, y=YB,
                mode="lines",  #Plot as a line
                fill="toself",
                fillcolor="black",  #Solid black color
                line=dict(color="black"),  
                opacity=1 , #Fully opaque,
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=[2, 2], col=[1, 2])

    #Update x-axis properties
    fig1.update_xaxes(#title_text='x',
                      title_font_color='#000000',
                      title_standoff=0,
                      gridcolor='rgba(153, 153, 153, 0.75)', #999999 in RGB
                      gridwidth=1,
                      zerolinecolor='#000000',
                      zerolinewidth=2,
                      linecolor='#000000',
                      linewidth=1,
                      ticks='outside',
                      ticklen=10,
                      tickwidth=2,
                      tickcolor='#000000',
                      tickfont_color='#000000',
                      minor_showgrid=True,
                      minor_gridcolor='rgba(221, 221, 221, 0.50)', #DDDDDD in RGB, 0.50 opacity
                      minor_ticks='outside',
                      minor_ticklen=5,
                      minor_tickwidth=2,
                      minor_griddash='dot',
                      hoverformat='.4f',
                     )
    
    #Update y-axis properties
    fig1.update_yaxes(#title_text='y',
                      title_font_color='#000000',
                      title_standoff=0,
                      gridcolor='rgba(153, 153, 153, 0.75)', #999999 in RGB, 0.75 opacity
                      gridwidth=1,
                      zerolinecolor='#000000',
                      zerolinewidth=2,
                      linecolor='#000000',
                      linewidth=1,
                      ticks='outside',
                      ticklen=10,
                      tickwidth=2,
                      tickcolor='#000000',
                      tickfont_color='#000000',
                      minor_showgrid=True,
                      minor_gridcolor='rgba(221, 221, 221, 0.50)', #DDDDDD in RGB, 0.50 opacity
                      minor_ticks='outside',
                      minor_ticklen=5,
                      minor_tickwidth=2,
                      minor_griddash='dot',

                     )
    
    fig1.update_xaxes(scaleanchor="y", row=1, col=1)
    fig1.update_xaxes(scaleanchor="y", row=1, col=2)
  
    #Update figure layout
    fig1.update_layout(font_color='#000000',
                       plot_bgcolor='rgba(255,255,255,1)',
                       paper_bgcolor='rgba(255,255,255,1)',
                       yaxis2=dict(autorange='reversed'),
                       showlegend=False,
                      )
    return fig1

def plotVortexAirfoil(alpha, V, name):

    # %% KNOWNS


    # %% KNOWNS

    # User-defined knowns
    Vinf = V                                                                        # Freestream velocity []
    AoA  = alpha                                                                        # Angle of attack [deg]
    
    if name == 1:
        XB, YB = airfoil_storage("NACA0012")
    elif name == 2:
        XB, YB = airfoil_storage("NACA2412")
    elif name == 3:
        XB, YB = airfoil_storage("NACA2404")
    elif name == 4:
        XB, YB = airfoil_storage("NACA4520")

    # Convert angle of attack to radians
    AoAR = AoA*(np.pi/180)                                                          # Angle of attack [rad]

    # Number of boundary points and panels
    numPts = len(XB)                                                                # Number of boundary points
    numPan = numPts - 1                                                             # Number of panels (control points)

    # %% CHECK PANEL DIRECTIONS - FLIP IF NECESSARY

    # Check for direction of points
    edge = np.zeros(numPan)                                                         # Initialize edge value array
    for i in range(numPan):                                                         # Loop over all panels
        edge[i] = (XB[i+1]-XB[i])*(YB[i+1]+YB[i])                                   # Compute edge values

    sumEdge = np.sum(edge)                                                          # Sum all edge values

    # If panels are CCW, flip them (don't if CW)
    if (sumEdge < 0):                                                               # If panels are CCW
        XB = np.flipud(XB)                                                          # Flip the X-data array
        YB = np.flipud(YB)                                                          # Flip the Y-data array

    # %% PANEL METHOD GEOMETRY - REF [1]

    # Initialize variables
    XC  = np.zeros(numPan)                                                          # Initialize control point X-coordinate array
    YC  = np.zeros(numPan)                                                          # Initialize control point Y-coordinate array
    S   = np.zeros(numPan)                                                          # Initialize panel length array
    phi = np.zeros(numPan)                                                          # Initialize panel orientation angle array [deg]

    # Find geometric quantities of the airfoil
    for i in range(numPan):                                                         # Loop over all panels
        XC[i]   = 0.5*(XB[i]+XB[i+1])                                               # X-value of control point
        YC[i]   = 0.5*(YB[i]+YB[i+1])                                               # Y-value of control point
        dx      = XB[i+1]-XB[i]                                                     # Change in X between boundary points
        dy      = YB[i+1]-YB[i]                                                     # Change in Y between boundary points
        S[i]    = (dx**2 + dy**2)**0.5                                              # Length of the panel
        phi[i]  = math.atan2(dy,dx)                                                 # Angle of panel (positive X-axis to inside face)
        if (phi[i] < 0):                                                            # Make all panel angles positive [rad]
            phi[i] = phi[i] + 2*np.pi

    # Compute angle of panel normal w.r.t. horizontal and include AoA
    delta                = phi + (np.pi/2)                                          # Angle from positive X-axis to outward normal vector [rad]
    beta                 = delta - AoAR                                             # Angle between freestream vector and outward normal vector [rad]
    beta[beta > 2*np.pi] = beta[beta > 2*np.pi] - 2*np.pi                           # Make all panel angles between 0 and 2pi [rad]

    # %% COMPUTE VORTEX PANEL STRENGTHS - REF [5]

    # Geometric integral (normal [K] and tangential [L])
    # - Refs [2] and [3]
    K, L = COMPUTE_KL_VPM(XC,YC,XB,YB,phi,S)                                        # Compute geometric integrals

    # Populate A matrix
    A = np.zeros([numPan,numPan])                                                   # Initialize the A matrix
    for i in range(numPan):                                                         # Loop over all i panels
        for j in range(numPan):                                                     # Loop over all j panels
            if (i == j):                                                            # If the panels are the same
                A[i,j] = 0                                                          # Set A equal to zero
            else:                                                                   # If panels are not the same
                A[i,j] = -K[i,j]                                                    # Set A equal to negative geometric integral
                
    # Populate b array
    b = np.zeros(numPan)                                                            # Initialize the b array
    for i in range(numPan):                                                         # Loop over all panels
        b[i] = -Vinf*2*np.pi*np.cos(beta[i])                                        # Compute RHS array

    # Satisfy the Kutta condition
    pct    = 100                                                                    # Panel replacement percentage
    panRep = int((pct/100)*numPan)-1                                                # Replace this panel with Kutta condition equation
    if (panRep >= numPan):                                                          # If we specify the last panel
        panRep = numPan-1                                                           # Set appropriate replacement panel index
    A[panRep,:]        = 0                                                          # Set all colums of the replaced panel equation to zero
    A[panRep,0]        = 1                                                          # Set first column of replaced panel equal to 1
    A[panRep,numPan-1] = 1                                                          # Set last column of replaced panel equal to 1
    b[panRep]          = 0                                                          # Set replaced panel value in b array equal to zero

    # Compute gamma values
    gamma = np.linalg.solve(A,b)                                                    # Compute all vortex strength values

    # %% COMPUTE PANEL VELOCITIES AND PRESSURE COEFFICIENTS

    # Compute velocities
    Vt = np.zeros(numPan)                                                           # Initialize tangential velocity array
    Cp = np.zeros(numPan)                                                           # Initialize pressure coefficient array
    for i in range(numPan):                                                         # Loop over all i panels
        addVal = 0                                                                  # Reset summation value to zero
        for j in range(numPan):                                                     # Loop over all j panels
            addVal = addVal - (gamma[j]/(2*np.pi))*L[i,j]                           # Sum all tangential vortex panel terms
        
        Vt[i] = Vinf*np.sin(beta[i]) + addVal + gamma[i]/2                          # Compute tangential velocity by adding uniform flow and i=j terms
        Cp[i] = 1 - (Vt[i]/Vinf)**2                                                 # Compute pressure coefficient

    """
    # %% COMPUTE LIFT AND MOMENT COEFFICIENTS

    # Compute normal and axial force coefficients
    CN = -Cp*S*np.sin(beta)                                                         # Normal force coefficient []
    CA = -Cp*S*np.cos(beta)                                                         # Axial force coefficient []

    # Compute lift, drag, and moment coefficients
    CL = sum(CN*np.cos(AoAR)) - sum(CA*np.sin(AoAR))                                # Decompose axial and normal to lift coefficient []
    CM = sum(Cp*(XC-0.25)*S*np.cos(phi))                                            # Moment coefficient []
    """

    # %% COMPUTE STREAMLINES - REF [4]

 
    # Grid parameters
    nGridX   = 40                                                              # X-grid for streamlines and contours
    nGridY   = 40                                                              # Y-grid for streamlines and contours
    xVals    = [-0.5, 1.5]                                                      # X-grid extents [min, max]
    yVals    = [-0.3, 0.3]                                                      # Y-grid extents [min, max]
        
    # Streamline parameters
    slPct  = 25                                                                 # Percentage of streamlines of the grid
    Ysl    = np.linspace(yVals[0],yVals[1],int((slPct/100)*nGridY))             # Create array of Y streamline starting points
    Xsl    = xVals[0]*np.ones(len(Ysl))                                         # Create array of X streamline starting points
    XYsl   = np.vstack((Xsl.T,Ysl.T)).T                                         # Concatenate X and Y streamline starting points
        
    # Generate the grid points
    Xgrid  = np.linspace(xVals[0],xVals[1],nGridX)                              # X-values in evenly spaced grid
    Ygrid  = np.linspace(yVals[0],yVals[1],nGridY)                              # Y-values in evenly spaced grid
    XX, YY = np.meshgrid(Xgrid,Ygrid)                                           # Create meshgrid from X and Y grid arrays
        
    # Initialize velocities
    Vx     = np.zeros([nGridX,nGridY])                                          # Initialize X velocity matrix
    Vy     = np.zeros([nGridX,nGridY])                                          # Initialize Y velocity matrix
        
    # Path to figure out if grid point is inside polygon or not
    AF     = np.vstack((XB.T,YB.T)).T                                           # Concatenate XB and YB geometry points
    afPath = path.Path(AF)                                                      # Create a path for the geometry
        
    # Solve for grid point X and Y velocities
    for m in range(nGridX):                                                     # Loop over X-grid points
        for n in range(nGridY):                                                 # Loop over Y-grid points
            XP     = XX[m,n]                                                    # Current iteration's X grid point
            YP     = YY[m,n]                                                    # Current iteration's Y grid point
            Nx, Ny = STREAMLINE_VPM(XP,YP,XB,YB,phi,S)                          # Compute Nx and Ny geometric integrals
                
            # Check if grid points are in object
            # - If they are, assign a velocity of zero
            if afPath.contains_points([(XP,YP)]):                               # If (XP,YP) is in the body
                Vx[m,n] = 0.0007                                                     # Set X-velocity equal to zero
                Vy[m,n] = 0.0007                                                     # Set Y-velocity equal to zero
            else:
                Vx[m,n] = Vinf*np.cos(AoAR) + sum(-gamma*Nx/(2*np.pi))          # Compute X-velocity
                Vy[m,n] = Vinf*np.sin(AoAR) + sum(-gamma*Ny/(2*np.pi))          # Compute Y-velocity
        
    # Compute grid point velocity magnitude and pressure coefficient
    Vxy  = np.sqrt(Vx**2 + Vy**2)                                               # Compute magnitude of velocity vector []
    CpXY = 1 - (Vxy/Vinf)**2                                                    # Pressure coefficient []

    ## ========================== ##
    ## ADD INFORMATION TO FIGUREs ##
    ## ========================== ##

    fig1 = make_subplots(rows=2, cols=2,
                         subplot_titles=("Panel Geometry", "Surface Pressure Distribution", "Pressure Field", "Airflow streamlines"), 
                         horizontal_spacing=0.3
                        )
    
    #Add plots
    fig1.add_trace(go.Scatter(
                name="Complete Panel Geometry",
                x=XB, y=YB,
                mode="lines",  #Plot as a line
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    fig1.add_trace(go.Scatter(
                name="Panel Boundary Points",
                x=XB, y=YB,
                mode='markers',  #Plot as a point
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    fig1.add_trace(go.Scatter(
                name="Panel Control Points",
                x=XC, y=YC,
                mode="markers",  #Plot as a point
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    #Separate Cp and Xc into upper and lower for plotting
    midIndS = int(np.floor(len(Cp)/2))
    XC_upper = XC[0:midIndS]
    CP_upper = Cp[0:midIndS] 
    XC_lower = XC[midIndS+1:len(XC)]
    CP_lower = Cp[midIndS+1:len(XC)]                                    

    fig1.add_trace(go.Scatter(
                name="Upper Cp",
                x=XC_upper, y=CP_upper,
                mode='markers',  #Plot as a point
                hovertemplate='Upper Cp<br>' +  
                  'x = %{x:.4f}<br>' +
                  'y = %{y:.4f}' +
                  '<extra></extra>',
                        ), row=1, col=2)
    
    fig1.add_trace(go.Scatter(
                name="Lower Cp",
                x=XC_lower, y=CP_lower,
                mode='markers',  #Plot as a point
                hovertemplate='Lower Cp<br>' + 
                  'x = %{x:.4f}<br>' +
                  'y = %{y:.4f}' +
                  '<extra></extra>',
                        ), row=1, col=2)
    
    fig1.add_trace(go.Contour(name="Pressure Field",
                              x=Xgrid, y=Ygrid, z=CpXY,
                              colorscale="RdBu_r", zmin=np.min(CpXY), zmax=np.max(CpXY),
                              contours=dict(start=np.min(CpXY),
                                            end  = np.max(CpXY),
                                            size = abs(np.min(CpXY) + np.max(CpXY)) / 100,
                                           ),
                              contours_showlines=False,
                              showscale=False,
                              hovertemplate='x = %{x:.4f}'+
                                            '<br>y = %{y:.4f}'+
                                            '<br>Cp = %{z:.4e}'+
                                            '<extra></extra>', ## '<extra></extra>' removes the trace name from hover text
                             ),
                   row=2, col=1
                  )
    
    #Append streamline
    Vx = np.where(Vx == 0, np.nan, Vx)
    Vy = np.where(Vy == 0, np.nan, Vy)
    streamlines = ff.create_streamline(Xgrid, Ygrid,
                                        Vx, Vy,
                                        density=0.8,
                                        arrow_scale=0.05,
                                        hoverinfo='skip',
                                        name='streamlines',
                                        line=dict(color='rgba(0,0,0,1)', width=0.75)
                                        )
    for t in streamlines.data:
        fig1.append_trace(t, row=2, col=2)
  
    
    fig1.add_trace(go.Contour(name="Velocity Field",
                              x=Xgrid, y=Ygrid, z=Vxy,
                              colorscale="RdBu_r", zmin=np.min(Vxy), zmax=np.max(Vxy),
                              contours=dict(start=np.min(Vxy),
                                            end  = np.max(Vxy),
                                            size = (np.min(Vxy) + np.max(Vxy)) / 100,
                                           ), 
                              contours_showlines=False,
                              showscale=False,
                              hovertemplate='x = %{x:.4f}'+
                                            '<br>y = %{y:.4f}'+
                                            '<br>Vmag = %{z:.4e}'+
                                            '<extra></extra>', ## '<extra></extra>' removes the trace name from hover text
                             ),
                   row=2, col=2
                  )

    fig1.add_trace(go.Scatter(
                name="Airfoil",
                x=XB, y=YB,
                mode="lines",  #Plot as a line
                fill="toself",
                fillcolor="black",  #Solid black color
                line=dict(color="black"),  
                opacity=1 , #Fully opaque,
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=[2, 2], col=[1, 2])

    #Update x-axis properties
    fig1.update_xaxes(#title_text='x',
                      title_font_color='#000000',
                      title_standoff=0,
                      gridcolor='rgba(153, 153, 153, 0.75)', #999999 in RGB
                      gridwidth=1,
                      zerolinecolor='#000000',
                      zerolinewidth=2,
                      linecolor='#000000',
                      linewidth=1,
                      ticks='outside',
                      ticklen=10,
                      tickwidth=2,
                      tickcolor='#000000',
                      tickfont_color='#000000',
                      minor_showgrid=True,
                      minor_gridcolor='rgba(221, 221, 221, 0.50)', #DDDDDD in RGB, 0.50 opacity
                      minor_ticks='outside',
                      minor_ticklen=5,
                      minor_tickwidth=2,
                      minor_griddash='dot',
                      hoverformat='.4f',
                     )
    
    #Update y-axis properties
    fig1.update_yaxes(#title_text='y',
                      title_font_color='#000000',
                      title_standoff=0,
                      gridcolor='rgba(153, 153, 153, 0.75)', #999999 in RGB, 0.75 opacity
                      gridwidth=1,
                      zerolinecolor='#000000',
                      zerolinewidth=2,
                      linecolor='#000000',
                      linewidth=1,
                      ticks='outside',
                      ticklen=10,
                      tickwidth=2,
                      tickcolor='#000000',
                      tickfont_color='#000000',
                      minor_showgrid=True,
                      minor_gridcolor='rgba(221, 221, 221, 0.50)', #DDDDDD in RGB, 0.50 opacity
                      minor_ticks='outside',
                      minor_ticklen=5,
                      minor_tickwidth=2,
                      minor_griddash='dot',

                     )
    
    fig1.update_xaxes(scaleanchor="y", row=1, col=1)
    fig1.update_xaxes(scaleanchor="y", row=1, col=2)
  
    #Update figure layout
    fig1.update_layout(font_color='#000000',
                       plot_bgcolor='rgba(255,255,255,1)',
                       paper_bgcolor='rgba(255,255,255,1)',
                       yaxis2=dict(autorange='reversed'),
                       showlegend=False,
                      )
    return fig1

def plotSourceVortexAirfoil(alpha, V, name):

    # %% KNOWNS

    # User-defined knowns
    Vinf = V                                                                        # Freestream velocity []
    AoA  = alpha                                                                        # Angle of attack [deg]
    
    if name == 1:
        XB, YB = airfoil_storage("NACA0012")
    elif name == 2:
        XB, YB = airfoil_storage("NACA2412")
    elif name == 3:
        XB, YB = airfoil_storage("NACA2404")
    elif name == 4:
        XB, YB = airfoil_storage("NACA4520")

    # Convert angle of attack to radians
    AoAR = AoA*(np.pi/180)                                                          # Angle of attack [rad]

    # Number of boundary points and panels
    numPts = len(XB)                                                                # Number of boundary points
    numPan = numPts - 1                                                             # Number of panels (control points)

    # %% CHECK PANEL DIRECTIONS - FLIP IF NECESSARY

    # Check for direction of points
    edge = np.zeros(numPan)                                                         # Initialize edge value array
    for i in range(numPan):                                                         # Loop over all panels
        edge[i] = (XB[i+1]-XB[i])*(YB[i+1]+YB[i])                                   # Compute edge values

    sumEdge = np.sum(edge)                                                          # Sum all edge values

    # If panels are CCW, flip them (don't if CW)
    if (sumEdge < 0):                                                               # If panels are CCW
        XB = np.flipud(XB)                                                          # Flip the X-data array
        YB = np.flipud(YB)                                                          # Flip the Y-data array

    # %% PANEL METHOD GEOMETRY - REF [1]

    # Initialize variables
    XC  = np.zeros(numPan)                                                          # Initialize control point X-coordinate array
    YC  = np.zeros(numPan)                                                          # Initialize control point Y-coordinate array
    S   = np.zeros(numPan)                                                          # Initialize panel length array
    phi = np.zeros(numPan)                                                          # Initialize panel orientation angle array [deg]

    # Find geometric quantities of the airfoil
    for i in range(numPan):                                                         # Loop over all panels
        XC[i]   = 0.5*(XB[i]+XB[i+1])                                               # X-value of control point
        YC[i]   = 0.5*(YB[i]+YB[i+1])                                               # Y-value of control point
        dx      = XB[i+1]-XB[i]                                                     # Change in X between boundary points
        dy      = YB[i+1]-YB[i]                                                     # Change in Y between boundary points
        S[i]    = (dx**2 + dy**2)**0.5                                              # Length of the panel
        phi[i]  = math.atan2(dy,dx)                                                 # Angle of panel (positive X-axis to inside face)
        if (phi[i] < 0):                                                            # Make all panel angles positive [rad]
            phi[i] = phi[i] + 2*np.pi

    # Compute angle of panel normal w.r.t. horizontal and include AoA
    delta                = phi + (np.pi/2)                                          # Angle from positive X-axis to outward normal vector [rad]
    beta                 = delta - AoAR                                             # Angle between freestream vector and outward normal vector [rad]
    beta[beta > 2*np.pi] = beta[beta > 2*np.pi] - 2*np.pi                           # Make all panel angles between 0 and 2pi [rad]

    # %% COMPUTE SOURCE AND VORTEX PANEL STRENGTHS - REF [10]

    # Geometric integrals for SPM and VPM (normal [I,K] and tangential [J,L])
    # - Refs [2], [3], [6], and [7]
    I, J = COMPUTE_IJ_SPM(XC,YC,XB,YB,phi,S)                                        # Call COMPUTE_IJ_SPM function (Refs [2] and [3])
    K, L = COMPUTE_KL_VPM(XC,YC,XB,YB,phi,S)                                        # Call COMPUTE_KL_VPM function (Refs [6] and [7])

    # Populate A matrix
    # - Simpler option: A = I + np.pi*np.eye(numPan,numPan)
    A = np.zeros([numPan,numPan])                                                   # Initialize the A matrix
    for i in range(numPan):                                                         # Loop over all i panels
        for j in range(numPan):                                                     # Loop over all j panels
            if (i == j):                                                            # If the panels are the same
                A[i,j] = np.pi                                                      # Set A equal to pi
            else:                                                                   # If panels are not the same
                A[i,j] = I[i,j]                                                     # Set A equal to I

    # Right column of A matrix
    newAV = np.zeros((numPan,1))                                                    # Used to enlarge the A matrix to account for gamma column
    A     = np.hstack((A,newAV))                                                    # Horizontally stack the A matrix with newAV to get enlarged matrix
    for i in range(numPan):                                                         # Loop over all i panels (rows)
        A[i,numPan] = -sum(K[i,:])                                                  # Add gamma term to right-most column of A matrix

    # Bottom row of A matrix
    newAH = np.zeros((1,numPan+1))                                                  # Used to enlarge the A matrix to account for Kutta condition equation
    A     = np.vstack((A,newAH))                                                    # Vertically stack the A matrix with newAH to get enlarged matrix
    for j in range(numPan):                                                         # Loop over all j panels (columns)
        A[numPan,j] = J[0,j] + J[numPan-1,j]                                        # Source contribution of Kutta condition equation
    A[numPan,numPan] = -(sum(L[0,:] + L[numPan-1,:])) + 2*np.pi                     # Vortex contribution of Kutta condition equation 

    # Populate b array
    # - Simpler option: b = -Vinf*2*np.pi*np.cos(beta)
    b = np.zeros(numPan)                                                            # Initialize the b array
    for i in range(numPan):                                                         # Loop over all i panels (rows)
        b[i] = -Vinf*2*np.pi*np.cos(beta[i])                                        # Compute RHS array

    # Last element of b array (Kutta condition)
    b = np.append(b,-Vinf*2*np.pi*(np.sin(beta[0]) + np.sin(beta[numPan-1])))       # Add Kutta condition equation RHS to b array

    # Compute result array
    resArr = np.linalg.solve(A,b)                                                   # Solve system of equation for all source strengths and single vortex strength

    # Separate lam and gamma values from result 
    lam   = resArr[0:len(resArr)-1]                                                 # All panel source strengths
    gamma = resArr[len(resArr)-1]                                                   # Constant vortex strength

    # %% COMPUTE PANEL VELOCITIES AND PRESSURE COEFFICIENTS

    # Compute velocities
    Vt = np.zeros(numPan)                                                           # Initialize tangential velocity
    Cp = np.zeros(numPan)                                                           # Initialize pressure coefficient
    for i in range(numPan):                                                         # Loop over all panels
        term1 = Vinf*np.sin(beta[i])                                                # Uniform flow term
        term2 = (1/(2*np.pi))*sum(lam*J[i,:])                                       # Source panel terms when j is not equal to i
        term3 = gamma/2                                                             # Vortex panel term when j is equal to i
        term4 = -(gamma/(2*np.pi))*sum(L[i,:])                                      # Vortex panel terms when j is not equal to i
        
        Vt[i] = term1 + term2 + term3 + term4                                       # Compute tangential velocity on panel i
        Cp[i] = 1-(Vt[i]/Vinf)**2                                                   # Compute pressure coefficient on panel i

    """
    # %% COMPUTE LIFT AND MOMENT COEFFICIENTS

    # Compute normal and axial force coefficients
    CN = -Cp*S*np.sin(beta)                                                         # Normal force coefficient []
    CA = -Cp*S*np.cos(beta)                                                         # Axial force coefficient []

    # Compute lift and moment coefficients
    CL = sum(CN*np.cos(AoAR)) - sum(CA*np.sin(AoAR))                                # Decompose axial and normal to lift coefficient []
    CM = sum(Cp*(XC-0.25)*S*np.cos(phi))                                            # Moment coefficient []
    """
 

    # %% COMPUTE STREAMLINES - REFS [4] and [8]

    
    # Grid parameters
    nGridX = 40                                                                # X-grid for streamlines and contours
    nGridY = 40                                                                # Y-grid for streamlines and contours
    xVals  = [min(XB)-0.5, max(XB)+0.5]                                         # X-grid extents [min, max]
    yVals  = [min(YB)-0.3, max(YB)+0.3]                                         # Y-grid extents [min, max]
        
    # Generate the grid points
    Xgrid  = np.linspace(xVals[0],xVals[1],nGridX)                              # X-values in evenly spaced grid
    Ygrid  = np.linspace(yVals[0],yVals[1],nGridY)                              # Y-values in evenly spaced grid
    XX, YY = np.meshgrid(Xgrid,Ygrid)                                           # Create meshgrid from X and Y grid arrays
        
    # Initialize velocities
    Vx     = np.zeros([nGridX,nGridY])                                          # Initialize X velocity matrix
    Vy     = np.zeros([nGridX,nGridY])                                          # Initialize Y velocity matrix
        
    # Path to figure out if grid point is inside polygon or not
    AF     = np.vstack((XB.T,YB.T)).T                                           # Concatenate XB and YB geometry points
    afPath = path.Path(AF)                                                      # Create a path for the geometry
        
    # Solve for grid point X and Y velocities
    for m in range(nGridX):                                                     # Loop over X-grid points
        for n in range(nGridY):                                                 # Loop over Y-grid points
            XP     = XX[m,n]                                                    # Current iteration's X grid point
            YP     = YY[m,n]                                                    # Current iteration's Y grid point
            Mx, My = STREAMLINE_SPM(XP,YP,XB,YB,phi,S)                          # Compute streamline Mx and My values
            Nx, Ny = STREAMLINE_VPM(XP,YP,XB,YB,phi,S)                          # Compute streamline Nx and Ny values
                
            # Check if grid points are in object
            # - If they are, assign a velocity of zero
            if afPath.contains_points([(XP,YP)]):                               # If (XP,YP) is in the body
                Vx[m,n] = 0.0007                                                     # Set X-velocity equal to zero
                Vy[m,n] = 0.0007                                                     # Set Y-velocity equal to zero
            else:
                Vx[m,n] = (Vinf*np.cos(AoAR) + sum(lam*Mx/(2*np.pi))            # Compute X-velocity
                                                + sum(-gamma*Nx/(2*np.pi)))
                Vy[m,n] = (Vinf*np.sin(AoAR) + sum(lam*My/(2*np.pi))            # Compute Y-velocity
                                                + sum(-gamma*Ny/(2*np.pi)))
        
    # Compute grid point velocity magnitude and pressure coefficient
    Vxy  = np.sqrt(Vx**2 + Vy**2)                                               # Compute magnitude of velocity vector []
    CpXY = 1 - (Vxy/Vinf)**2                                                    # Pressure coefficient []

    ## ========================== ##
    ## ADD INFORMATION TO FIGUREs ##
    ## ========================== ##

    fig1 = make_subplots(rows=2, cols=2,
                         subplot_titles=("Panel Geometry", "Surface Pressure Distribution", "Pressure Field", "Airflow streamlines"), 
                         horizontal_spacing=0.3
                        )
    
    #Add plots
    fig1.add_trace(go.Scatter(
                name="Complete Panel Geometry",
                x=XB, y=YB,
                mode="lines",  #Plot as a line
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    fig1.add_trace(go.Scatter(
                name="Panel Boundary Points",
                x=XB, y=YB,
                mode='markers',  #Plot as a point
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    fig1.add_trace(go.Scatter(
                name="Panel Control Points",
                x=XC, y=YC,
                mode="markers",  #Plot as a point
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=1, col=1)
    
    #Separate Cp and Xc into upper and lower for plotting
    midIndS = int(np.floor(len(Cp)/2))
    XC_upper = XC[0:midIndS]
    CP_upper = Cp[0:midIndS] 
    XC_lower = XC[midIndS+1:len(XC)]
    CP_lower = Cp[midIndS+1:len(XC)]                                    

    fig1.add_trace(go.Scatter(
                name="Upper Cp",
                x=XC_upper, y=CP_upper,
                mode='markers',  #Plot as a point
                hovertemplate='Name: %{meta}<br>' +  
                  'x = %{x:.4f}<br>' +
                  'y = %{y:.4f}' +
                  '<extra></extra>',
                        ), row=1, col=2)
    
    fig1.add_trace(go.Scatter(
                name="Lower Cp",
                x=XC_lower, y=CP_lower,
                mode='markers',  #Plot as a point
                hovertemplate='Name: %{meta}<br>' + 
                  'x = %{x:.4f}<br>' +
                  'y = %{y:.4f}' +
                  '<extra></extra>',
                        ), row=1, col=2)
    
    fig1.add_trace(go.Contour(name="Pressure Field",
                              x=Xgrid, y=Ygrid, z=CpXY,
                              colorscale="RdBu_r", zmin=np.min(CpXY), zmax=np.max(CpXY),
                              contours=dict(start=np.min(CpXY),
                                            end  = np.max(CpXY),
                                            size = abs(np.min(CpXY) + np.max(CpXY)) / 100,
                                           ),
                              contours_showlines=False,
                              showscale=False,
                              hovertemplate='x = %{x:.4f}'+
                                            '<br>y = %{y:.4f}'+
                                            '<br>Cp = %{z:.4e}'+
                                            '<extra></extra>', ## '<extra></extra>' removes the trace name from hover text
                             ),
                   row=2, col=1
                  )
    
    #Append streamline
    Vx = np.where(Vx == 0, np.nan, Vx)
    Vy = np.where(Vy == 0, np.nan, Vy)
    streamlines = ff.create_streamline(Xgrid, Ygrid,
                                        Vx, Vy,
                                        density=0.8,
                                        arrow_scale=0.05,
                                        hoverinfo='skip',
                                        name='streamlines',
                                        line=dict(color='rgba(0,0,0,1)', width=0.75)
                                        )
    for t in streamlines.data:
        fig1.append_trace(t, row=2, col=2)
  
    
    fig1.add_trace(go.Contour(name="Velocity Field",
                              x=Xgrid, y=Ygrid, z=Vxy,
                              colorscale="RdBu_r", zmin=np.min(Vxy), zmax=np.max(Vxy),
                              contours=dict(start=np.min(Vxy),
                                            end  = np.max(Vxy),
                                            size = (np.min(Vxy) + np.max(Vxy)) / 100,
                                           ), 
                              contours_showlines=False,
                              showscale=False,
                              hovertemplate='x = %{x:.4f}'+
                                            '<br>y = %{y:.4f}'+
                                            '<br>Vmag = %{z:.4e}'+
                                            '<extra></extra>', ## '<extra></extra>' removes the trace name from hover text
                             ),
                   row=2, col=2
                  )

    fig1.add_trace(go.Scatter(
                name="Airfoil",
                x=XB, y=YB,
                mode="lines",  #Plot as a line
                fill="toself",
                fillcolor="black",  #Solid black color
                line=dict(color="black"),  
                opacity=1 , #Fully opaque,
                hovertemplate='x = %{x:.4f}'+
                  '<br>y = %{y:.4f}'+
                  '<extra></extra>',
                        ), row=[2, 2], col=[1, 2])

    #Update x-axis properties
    fig1.update_xaxes(#title_text='x',
                      title_font_color='#000000',
                      title_standoff=0,
                      gridcolor='rgba(153, 153, 153, 0.75)', #999999 in RGB
                      gridwidth=1,
                      zerolinecolor='#000000',
                      zerolinewidth=2,
                      linecolor='#000000',
                      linewidth=1,
                      ticks='outside',
                      ticklen=10,
                      tickwidth=2,
                      tickcolor='#000000',
                      tickfont_color='#000000',
                      minor_showgrid=True,
                      minor_gridcolor='rgba(221, 221, 221, 0.50)', #DDDDDD in RGB, 0.50 opacity
                      minor_ticks='outside',
                      minor_ticklen=5,
                      minor_tickwidth=2,
                      minor_griddash='dot',
                      hoverformat='.4f',
                     )
    
    #Update y-axis properties
    fig1.update_yaxes(#title_text='y',
                      title_font_color='#000000',
                      title_standoff=0,
                      gridcolor='rgba(153, 153, 153, 0.75)', #999999 in RGB, 0.75 opacity
                      gridwidth=1,
                      zerolinecolor='#000000',
                      zerolinewidth=2,
                      linecolor='#000000',
                      linewidth=1,
                      ticks='outside',
                      ticklen=10,
                      tickwidth=2,
                      tickcolor='#000000',
                      tickfont_color='#000000',
                      minor_showgrid=True,
                      minor_gridcolor='rgba(221, 221, 221, 0.50)', #DDDDDD in RGB, 0.50 opacity
                      minor_ticks='outside',
                      minor_ticklen=5,
                      minor_tickwidth=2,
                      minor_griddash='dot',

                     )
    
    fig1.update_xaxes(scaleanchor="y", row=1, col=1)
    fig1.update_xaxes(scaleanchor="y", row=1, col=2)
  
    #Update figure layout
    fig1.update_layout(font_color='#000000',
                       plot_bgcolor='rgba(255,255,255,1)',
                       paper_bgcolor='rgba(255,255,255,1)',
                       yaxis2=dict(autorange='reversed'),
                       showlegend=False,
                      )
    return fig1